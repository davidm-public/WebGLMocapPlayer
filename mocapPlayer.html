<!DOCTYPE html>
<html lang="en">
	<head>
		<title>WebGL Mocap Viewer</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
		
		</style>
		<link rel="stylesheet" href="style/pace.css"></link>

		<script src="js/bvhReader.js"></script>
		<script src="bower_components/PACE/pace.min.js"></script>
		<script src="bower_components/mathjs/dist/math.min.js"></script>
		<script src="bower_components/jquery/dist/jquery.min.js"></script>
		<script src="bower_components/three.js/build/three.min.js"></script>
		<script src="bower_components/three.js/examples/js/loaders/ColladaLoader.js"></script>
		<script src="bower_components/three.js/examples/js/loaders/AssimpJSONLoader.js"></script>
		<script src="bower_components/three.js/examples/js/controls/OrbitControls.js"></script>
		<script src="bower_components/three.js/examples/js/loaders/collada/Animation.js"></script>
		<script src="bower_components/three.js/examples/js/controls/OrbitControls.js"></script>
	</head>
	<body>
		<script type="text/javascript">
		var jointMeshes = [];
		var boneMeshes = [];
		var rootMeshes = [];
		var animIndex = 1;

		var animStartTimeRef = [];
		var animOffset = 0;
		var playing = false;

		var skelScale = 2;

		 var bvhFileName = "res/AV_8Walk_Meredith_HVHA_Rep1.bvh";
		// var bvhFileName = "res/35_01.bvh";
		// var bvhFileName = "res/05_07.bvh";
		var bvhFileName = "res/38_03.bvh";
		// var bvhFileName = "res/10_HVHA_8_walk_meredith1.bvh";
		// var bvhFileName = "res/GEMMA_DANCE_TRACK1_0002.bvh";

		function load_bvh() {
			jointmaterial = new THREE.MeshBasicMaterial( { color: 0x0066ff, wireframe: true } );
			jointmaterial2 = new THREE.MeshPhongMaterial({
					color: 0x1562a2,
					emissive: 0x072554,
					color: 0x302221,
					emissive: 0x501111,
					side: THREE.DoubleSide,
					shading: THREE.FlatShading
				});
			bonematerial = new THREE.MeshBasicMaterial( { color: 0x00ff66, wireframe: true } );
			bonematerial2 = new THREE.MeshPhongMaterial({
					color: 0x552211,
					emissive: 0x551111,
					side: THREE.DoubleSide,
					shading: THREE.FlatShading
				});

			console.log("Loading the BVH file ...");
			Pace.start();
			var reader = new BVHReader();

			reader.load(bvhFileName, function(data){
				bvh = data;
				console.log("BVH file loaded.");

				buildSkelJoints(bvh.getSkeleton(),0);

				// rootMesh = new THREE.Mesh(new THREE.SphereGeometry(1,1,1), bonematerial2);
				// rootMesh.joint = jointMeshes[0];
				// rootMesh.name = "root";
				// boneMeshes.push(rootMesh);
				(buildSkelBones(jointMeshes[0])).forEach(function (c){
					rootMeshes.push(c);
					scene.add(c);
					//c.scale.set(1,skelScale,1);
				});

				scene.add(jointMeshes[0]);
				
				//scene.add(boneMeshes[25]);
			});
		}

		function buildSkelJoints(joint, parent) {
			var jointMesh = new THREE.Mesh(new THREE.SphereGeometry(1,60,60), jointmaterial2);
			jointMesh.bvhIndex = joint.jointIndex;
			jointMesh.offsetVec = new THREE.Vector3(joint.offset[0],joint.offset[1],joint.offset[2]);
			jointMesh.name = joint.name;
			jointMesh.jointparent = parent;
			var a,b,c;
					if (!joint.isEndSite()) {
						a = joint.channelNames[joint.channelNames.length - 3][0];
						b = joint.channelNames[joint.channelNames.length - 2][0];
						c = joint.channelNames[joint.channelNames.length - 1][0];
					}
			jointMesh.rotOrder = a+b+c;

			jointMeshes.push(jointMesh);
			joint.children.forEach(function (child) {
				jointMesh.add(buildSkelJoints(child, 1));
			});

			return jointMesh;
		}

		function buildSkelBones(jointMesh) {
		var bones = [];
		jointMesh.children.forEach(function (childMesh) {
			// if (typeof childMesh.bvhIndex !== "undefined")
			{
				h = math.abs(childMesh.offsetVec.length());
				var bgeometry = new THREE.CylinderGeometry(1.5,0.7,h,40);
				
				if (childMesh.offsetVec.x == 0)
					bgeometry.rotateX(math.pi/2);
				// if (childMesh.offsetVec.y != 0)
					bgeometry.rotateY(math.pi/2);
				// if (childMesh.offsetVec.z != 0)
					bgeometry.rotateZ(math.pi/2);	

				bgeometry.translate(childMesh.offsetVec.x/2, childMesh.offsetVec.y/2, childMesh.offsetVec.z/2 );

				var boneMesh = new THREE.Mesh(bgeometry, bonematerial2);	
				boneMesh.joint = jointMesh;
				boneMesh.name = jointMesh.name + " > " + childMesh.name;
				boneMeshes.push(boneMesh);
				// scene.add(boneMesh);
				bones.push(boneMesh);		

				(buildSkelBones(childMesh)).forEach(function (b) {
					boneMesh.add(b);
				});				
			}
		});	
		return bones;		
		}


		function angle_trunc(a) {
			while (a < -Math.PI)  
				a += Math.PI * 2;
			while (a >= Math.PI)  
				a -= Math.PI * 2;
			//lse
			//	return a;
			return a;
		}

		function animFrame(frame) {

			jointMeshes[0].traverse(function (joint) {
				var bj = bvh.jointArray[joint.bvhIndex];

				var offsetVec = joint.offsetVec;
				var torad = Math.PI / 180;
				var thisEuler = [];

				if (joint.jointparent != 0) {
				 thisEuler = new THREE.Euler(
					angle_trunc(bj.channels[frame][bj.rotationIndex.x] * torad),
					angle_trunc(bj.channels[frame][bj.rotationIndex.y] * torad),
					angle_trunc(bj.channels[frame][bj.rotationIndex.z] * torad),joint.rotOrder);
				} else {
				 thisEuler = new THREE.Euler(
					angle_trunc(bj.channels[frame][bj.rotationIndex.x] * torad),
					angle_trunc(bj.channels[frame][bj.rotationIndex.y] * torad),
					angle_trunc(bj.channels[frame][bj.rotationIndex.z] * torad),joint.rotOrder);	
				}


				joint.localRotMat = new THREE.Matrix4();
				joint.localRotMat.makeRotationFromEuler(thisEuler);

				if (joint.jointparent != 0) {					
					// joint.worldRotMat = new THREE.Matrix4();
					// joint.worldRotMat.multiplyMatrices(joint.jointparent.worldRotMat,joint.localRotMat);

					joint.rotation.setFromRotationMatrix(joint.localRotMat);

					joint.position.set(offsetVec.x, offsetVec.y, offsetVec.z);
				} 
				else {
					joint.rotation.setFromRotationMatrix(joint.localRotMat);
					joint.worldRotMat = joint.localRotMat.clone();

					joint.position.set(
						bj.positions[frame][0],
						bj.positions[frame][1],
						bj.positions[frame][2]);
				}
			});

			// boneMeshes[0].traverse(function (bone) { 
			// 	if (frame == 2) console.log(bone.joint.name);
			// 	bone.rotation.setFromRotationMatrix(bone.joint.localRotMat);
			// 	bone.position.copy(bone.joint.position);
			// });

			rootMeshes.forEach(function(rootMesh) {
				rootMesh.traverse(function(bone,index) {
				var bj = bvh.jointArray[bone.joint.bvhIndex];

				var offsetVec = new THREE.Vector3(bj.offset[0],bj.offset[1],bj.offset[2]);

				if ( bone.parent.type === "Scene")  
				{
					bone.position.set(bj.positions[frame][0],
								  bj.positions[frame][1],
								  bj.positions[frame][2]);
				} else {
					bone.position.set(offsetVec.x,
									offsetVec.y,
									offsetVec.z);
				}
				
				bone.rotation.copy(bone.joint.rotation);//setFromRotationMatrix(bone.joint.localRotMat);				

			});
			});

			//camera.lookAt(rootMeshes[0].position);
			
		}
		
		$(document).on("keypress", function (e) {
    		if (e.charCode == 32)
    			playing = !playing;

    		if (playing)
    			animStartTimeRef = Date.now();
    		else
    			animOffset = animIndex;
		});
		</script>
		<script>
		var scene, camera, renderer;
		var geometry, material, mesh;
		
		init();

		animate();

		function set_the_scene() {
			// Lights
			var lights = [];
			lights[0] = new THREE.PointLight( 0xffffff, 1, 0 );
			lights[1] = new THREE.PointLight( 0xffffff, 1, 0 );
			lights[2] = new THREE.PointLight( 0xffffff, 1, 0 );
			lights[0].position.set( 0, 200, 0 );
			lights[1].position.set( 100, 200, 100 );
			lights[2].position.set( -100, -200, -100 );

			scene.add( lights[0] );
			scene.add( lights[1] );
			scene.add( lights[2] );

			var ambientLight = new THREE.AmbientLight( 0x000000 );
			scene.add( ambientLight );

			// Grid
			var size = 170, step = 20;

			var geometry = new THREE.PlaneGeometry( size*2, size*2);
			var material = new THREE.MeshBasicMaterial( {color: 0x707070, side: THREE.DoubleSide, transparent: true, opacity: 0.7} );
			var plane = new THREE.Mesh( geometry, material );
			plane.position.set(0,0,0);
			plane.rotation.set(math.pi/2,0,0);
			scene.add( plane );

			var geometry = new THREE.Geometry();
			var material = new THREE.LineBasicMaterial( { color: 0x222222,linewidth: 1.2 } );
			for ( var i = - size; i <= size; i += step ) {
				geometry.vertices.push( new THREE.Vector3( - size, - 0.04, i ) );
				geometry.vertices.push( new THREE.Vector3(   size, - 0.04, i ) );
				geometry.vertices.push( new THREE.Vector3( i, - 0.04, - size ) );
				geometry.vertices.push( new THREE.Vector3( i, - 0.04,   size ) );
			}

			var line = new THREE.LineSegments( geometry, material );
			scene.add( line );
		}

		function init() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 3000 );
			camera.position.set( 0, 80, 0 );
			camera.position.z = 350;
			scene.add(camera);
			set_the_scene();
			
			load_bvh();

			renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );

			renderer.setClearColor( 0xdddddd, 1);
			document.body.appendChild( renderer.domElement );

			controls = new THREE.OrbitControls( camera, renderer.domElement );
		}

		function animate() {
			requestAnimationFrame( animate );
			
			if (1 && typeof bvh !== 'undefined'){		
				if (playing) {
					animIndex = animOffset + Math.floor( (Date.now() - animStartTimeRef) / bvh.frameTime / 1000);

					if (animIndex >= bvh.frameCount) {
						animOffset = 0;
						animStartTimeRef = Date.now();
						animIndex = 0;
					}
					animFrame(animIndex);
				}
				

			}
			renderer.render( scene, camera );
		}
		</script>
	</body>
</html>