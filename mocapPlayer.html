<!DOCTYPE html>
<html lang="en">
	<head>
		<title>WebGL Mocap Viewer</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
		
		</style>
		<link rel="stylesheet" href="style/pace.css"></link>

		<script src="js/bvhReader.js"></script>
		<script src="bower_components/PACE/pace.min.js"></script>
		<script src="bower_components/mathjs/dist/math.min.js"></script>
		<script src="bower_components/jquery/dist/jquery.min.js"></script>
		<script src="bower_components/three.js/build/three.min.js"></script>
		<script src="bower_components/three.js/examples/js/loaders/ColladaLoader.js"></script>
		<script src="bower_components/three.js/examples/js/loaders/AssimpJSONLoader.js"></script>
		<script src="bower_components/three.js/examples/js/controls/OrbitControls.js"></script>
		<script src="bower_components/three.js/examples/js/loaders/collada/Animation.js"></script>
		<script src="bower_components/three.js/examples/js/controls/OrbitControls.js"></script>
	</head>
	<body>
		<script type="text/javascript">
		var jointMeshes = [];
		var boneMeshes = [];
		var boneLines = [];
		var animIndex = 1;

		var animStartTimeRef = [];
		var animOffset = 0;
		var playing = false;

		 var bvhFileName = "res/AV_8Walk_Meredith_HVHA_Rep1.bvh";
		// var bvhFileName = "res/35_01.bvh";
		//var bvhFileName = "res/10_HVHA_8_walk_meredith1.bvh";
		// var bvhFileName = "res/GEMMA_DANCE_TRACK1_0002.bvh";

		function load_bvh() {
			jointmaterial = new THREE.MeshBasicMaterial( { color: 0x0066ff, wireframe: true } );
			jointmaterial2 = new THREE.MeshPhongMaterial({
					color: 0x156289,
					emissive: 0x072534,
					side: THREE.DoubleSide,
					shading: THREE.FlatShading
				});
			bonematerial = new THREE.MeshBasicMaterial( { color: 0x00ff66, wireframe: true } );
			bonematerial2 = new THREE.MeshPhongMaterial({
					color: 0x221133,
					emissive: 0x276734,
					side: THREE.DoubleSide,
					shading: THREE.FlatShading
				});

			console.log("Loading the BVH file ...");
			Pace.start();
			var reader = new BVHReader();

			reader.load(bvhFileName, function(data){
				bvh = data;
				console.log("BVH file loaded.");

				if (1) {
					buildSkel(bvh.getSkeleton(),0);
				}
				else {
					bvh.jointArray.forEach(function(joint, index) {
					var jointMesh = new THREE.Mesh(new THREE.SphereGeometry(1.5,40,40), jointmaterial2);
					jointMesh.bvhIndex = joint.jointIndex;

					var a,b,c;

					if (!joint.isEndSite()) {
						a = joint.channelNames[joint.channelNames.length - 3][0];
						b = joint.channelNames[joint.channelNames.length - 2][0];
						c = joint.channelNames[joint.channelNames.length - 1][0];
					}

					jointMesh.rotOrder = a+b+c;
					// console.log(a+b+c);
					
					jointMeshes.push(jointMesh);

					scene.add(jointMesh);
				});
				}
				
				bvh.connectivityMatrix.forEach(function(bb, index) {
					st = new THREE.Vector3().fromArray(bb[0].positions[0]);
					en = new THREE.Vector3().fromArray(bb[1].positions[0]);
					var h = st.distanceTo(en);
					var bgeometry = new THREE.CylinderGeometry(1,1,h,20);

					bgeometry.translate(0, -h/2, 0 );

					var boneMesh = new THREE.Mesh(bgeometry, bonematerial2);
					boneMesh.joint1Index = bb[0].jointIndex;
					boneMesh.joint2Index = bb[1].jointIndex;

					boneMeshes.push(boneMesh);
					scene.add(boneMesh);
				});

				
			});
		}

		function buildSkel(joint, parent) {
			var jointMesh = new THREE.Mesh(new THREE.SphereGeometry(1.5,40,40), jointmaterial2);
			jointMesh.bvhIndex = joint.jointIndex;

			var a,b,c;

			if (!joint.isEndSite()) {
				a = joint.channelNames[joint.channelNames.length - 3][0];
				b = joint.channelNames[joint.channelNames.length - 2][0];
				c = joint.channelNames[joint.channelNames.length - 1][0];
			}

			jointMesh.rotOrder = a+b+c;
			 
			jointMesh.jointparent = parent;

			jointMeshes.push(jointMesh);
			scene.add(jointMesh);

			joint.children.forEach(function (child) {
				jointMesh.add(buildSkel(child, jointMesh));
			});

			return jointMesh;
		}


		function angle_trunc(a) {
			while (a < 0)
				 a += math.pi * 2;
			//lse
			//	return a;
			return a;
		}

		function animFrame(frame) {
			jointMeshes.forEach(function(joint, index) {
				var bj = bvh.jointArray[joint.bvhIndex];

				
				var offsetVec = new THREE.Vector3(bj.offset[0],bj.offset[1],bj.offset[1]);


				var thisEuler = new THREE.Euler(
				bj.channels[frame][bj.rotationIndex.x]* Math.PI / 180,
				bj.channels[frame][bj.rotationIndex.y]* Math.PI / 180,
				bj.channels[frame][bj.rotationIndex.z]* Math.PI / 180);


				joint.localRotMat = new THREE.Matrix4();
				joint.localRotMat.makeRotationFromEuler(thisEuler);


				if (joint.jointparent != 0) {
					// var t = (new THREE.Matrix4()).multiplyMatrices(offsetMat,joint.jointparent.worldRotMat);
					// var v = new THREE.Vector3(t.elements[12],t.elements[13],t.elements[14]);

					var t = offsetVec.clone();
					//t.applyMatrix4(joint.jointparent.worldRotMat);
//					t.add(joint.jointparent.position);
					joint.position.set(t.x, t.y, t.z);

					// joint.worldRotMat = new THREE.Matrix4();
					// joint.worldRotMat.multiplyMatrices(joint.localRotMat,joint.jointparent.worldRotMat);

					joint.worldRotMat = joint.localRotMat.clone();
					joint.rotation.setFromRotationMatrix(joint.worldRotMat);
				} 
				else {
					joint.position.set(
					bj.positions[frame][0],
					bj.positions[frame][1],
					bj.positions[frame][2]);

					joint.rotation.setFromRotationMatrix(joint.localRotMat);
					joint.worldRotMat = joint.localRotMat.clone();
				}
				

			});

			boneMeshes.forEach(function(bone, index) {
				firstJointMesh = jointMeshes[bone.joint1Index];
				firstJoint = bvh.jointArray[bone.joint1Index];


				bone.rotation.setFromRotationMatrix(firstJointMesh.worldRotMat);
				
				bone.position.set(firstJoint.positions[frame][0],
								  firstJoint.positions[frame][1],
								  firstJoint.positions[frame][2]);


			});
		}

		function animFrame0(frame) {
			jointMeshes.forEach(function(joint, index) {
				joint.position.set(
					bvh.jointArray[joint.bvhIndex].positions[frame][0],
					bvh.jointArray[joint.bvhIndex].positions[frame][1],
					bvh.jointArray[joint.bvhIndex].positions[frame][2]);
			});

			boneMeshes.forEach(function(bone, index) {
				firstJoint = bvh.jointArray[bone.joint1Index];
				secondJoint = bvh.jointArray[bone.joint2Index];

				var offsetMat = new THREE.Matrix4();
				offsetMat.set(1,0,0,firstJoint.offset[0],
							  0,1,0,firstJoint.offset[1],
							  0,0,1,firstJoint.offset[2],
							  0,0,0,1);

				
				var rotMat = new THREE.Matrix4();
				var R = firstJoint.rotations[frame];
				rotMat.set(R[0][0],R[1][0],R[2][0],0,
						   R[0][1],R[1][1],R[2][1],0,
						   R[0][2],R[1][2],R[2][2],0,
							0	  ,0      ,0      ,0);


				// rotMat.set(R[0][0],R[0][1],R[0][2],0,
				// 		   R[1][0],R[1][1],R[1][2],0,
				// 		   R[2][0],R[2][1],R[2][2],0,
				// 			0	  ,0      ,0      ,1);				


				//bone.rotation.setFromRotationMatrix(rotMat, "ZXY");



				var thisEuler = new THREE.Euler(
					firstJoint.channels[frame][firstJoint.rotationIndex.x]* Math.PI / 180,
					firstJoint.channels[frame][firstJoint.rotationIndex.y]* Math.PI / 180,
					firstJoint.channels[frame][firstJoint.rotationIndex.z]* Math.PI / 180);

				var thisLocalRotMat = new THREE.Matrix4();
				thisLocalRotMat.makeRotationFromEuler(thisEuler);

				bone.rotation.setFromRotationMatrix(thisLocalRotMat);
				
				//bone.rotation.set(thisEuler.x, thisEuler.y, thisEuler.z);

				bone.position.set(firstJoint.positions[frame][0],
								  firstJoint.positions[frame][1],
								  firstJoint.positions[frame][2]);

				/// move origin (.translate)
				/// rotate
				/// translate (world position + offeset)

			});
		}


		
		$(document).on("keypress", function (e) {
    		if (e.charCode == 32)
    			playing = !playing;

    		if (playing)
    			animStartTimeRef = Date.now();
    		else
    			animOffset = animIndex;
		});
		</script>
		<script>
		var scene, camera, renderer;
		var geometry, material, mesh;
		
		init();
		animate();

		function set_the_scene() {
			// Lights
			var lights = [];
			lights[0] = new THREE.PointLight( 0xffffff, 1, 0 );
			lights[1] = new THREE.PointLight( 0xffffff, 1, 0 );
			lights[2] = new THREE.PointLight( 0xffffff, 1, 0 );
			lights[0].position.set( 0, 200, 0 );
			lights[1].position.set( 100, 200, 100 );
			lights[2].position.set( -100, -200, -100 );

			scene.add( lights[0] );
			scene.add( lights[1] );
			scene.add( lights[2] );

			var ambientLight = new THREE.AmbientLight( 0x000000 );
			scene.add( ambientLight );

			// Grid
			var size = 170, step = 20;

			var geometry = new THREE.PlaneGeometry( size*2, size*2);
			var material = new THREE.MeshBasicMaterial( {color: 0x707070, side: THREE.DoubleSide, transparent: true, opacity: 0.7} );
			var plane = new THREE.Mesh( geometry, material );
			plane.position.set(0,0,0);
			plane.rotation.set(math.pi/2,0,0);
			scene.add( plane );

			var geometry = new THREE.Geometry();
			var material = new THREE.LineBasicMaterial( { color: 0x222222,linewidth: 1.2 } );
			for ( var i = - size; i <= size; i += step ) {
				geometry.vertices.push( new THREE.Vector3( - size, - 0.04, i ) );
				geometry.vertices.push( new THREE.Vector3(   size, - 0.04, i ) );
				geometry.vertices.push( new THREE.Vector3( i, - 0.04, - size ) );
				geometry.vertices.push( new THREE.Vector3( i, - 0.04,   size ) );
			}

			var line = new THREE.LineSegments( geometry, material );
			scene.add( line );
		}

		function init() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
			camera.position.set( 20, 80, 3 );
			camera.position.z = 300;

			set_the_scene();
			
			load_bvh();

			renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );

			renderer.setClearColor( 0xdddddd, 1);
			document.body.appendChild( renderer.domElement );

			controls = new THREE.OrbitControls( camera, renderer.domElement );
		}

		function animate() {
			requestAnimationFrame( animate );
			
			if (1 && typeof bvh !== 'undefined'){		
				if (playing) {
					animIndex = animOffset + Math.floor( (Date.now() - animStartTimeRef) / bvh.frameTime / 1000);

					if (animIndex >= bvh.frameCount) {
						animOffset = 0;
						animStartTimeRef = Date.now();
						animIndex = 0;
					}
					animFrame(animIndex);
				}
				

			}
			renderer.render( scene, camera );
		}
		</script>
	</body>
</html>