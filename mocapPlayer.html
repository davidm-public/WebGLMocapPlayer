<!DOCTYPE html>
<html lang="en">
	<head>
		<title>WebGL Mocap Viewer</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
		
		</style>
		<link rel="stylesheet" href="style/pace.css"></link>

		<script src="js/bvhReader.js"></script>
		<script src="bower_components/PACE/pace.min.js"></script>
		<script src="bower_components/mathjs/dist/math.min.js"></script>
		<script src="bower_components/jquery/dist/jquery.min.js"></script>
		<script src="bower_components/three.js/build/three.min.js"></script>
		<script src="bower_components/three.js/examples/js/loaders/ColladaLoader.js"></script>
		<script src="bower_components/three.js/examples/js/loaders/AssimpJSONLoader.js"></script>
		<script src="bower_components/three.js/examples/js/controls/OrbitControls.js"></script>
		<script src="bower_components/three.js/examples/js/loaders/collada/Animation.js"></script>
		<script src="bower_components/three.js/examples/js/controls/OrbitControls.js"></script>
	</head>
	<body>
		<script type="text/javascript">
		var jointMeshes = [];
		var boneMeshes = [];
		var boneLines = [];
		var animIndex = 1;

		var animStartTimeRef = [];
		var animOffset = 0;
		var playing = false;

		// var bvhFileName = "res/AV_8Walk_Meredith_HVHA_Rep1.bvh";
		// var bvhFileName = "res/35_01.bvh";
		var bvhFileName = "res/10_HVHA_8_walk_meredith1.bvh";
		//var bvhFileName = "res/GEMMA_DANCE_TRACK1_0002.bvh";

		function load_bvh() {
			jointmaterial = new THREE.MeshBasicMaterial( { color: 0x0066ff, wireframe: true } );
			jointmaterial2 = new THREE.MeshPhongMaterial({
					color: 0x156289,
					emissive: 0x072534,
					side: THREE.DoubleSide,
					shading: THREE.FlatShading
				});
			bonematerial = new THREE.MeshBasicMaterial( { color: 0x00ff66, wireframe: true } );
			bonematerial2 = new THREE.MeshPhongMaterial({
					color: 0x221133,
					emissive: 0x276734,
					side: THREE.DoubleSide,
					shading: THREE.FlatShading
				});

			console.log("Loading the BVH file ...");
			Pace.start();
			var reader = new BVHReader();

			reader.load(bvhFileName, function(data){
				bvh = data;
				console.log("BVH file loaded.");

				bvh.jointArray.forEach(function(joint, index) {
					var jointMesh = new THREE.Mesh(new THREE.SphereGeometry(1.5,40,40), jointmaterial2);
					jointMesh.bvhIndex = index;

					var a,b,c;

					if (!joint.isEndSite()) {
					a = joint.channelNames[joint.channelNames.length - 3][0];
					b = joint.channelNames[joint.channelNames.length - 2][0];
					c = joint.channelNames[joint.channelNames.length - 1][0];

				}

					jointMesh.rotOrder = a+b+c;
					console.log(a+b+c);

					jointMeshes.push(jointMesh);
					scene.add(jointMesh);
				});
				
				bvh.connectivityMatrix.forEach(function(bb, index) {
					st = new THREE.Vector3().fromArray(bb[0].positions[0]);
					en = new THREE.Vector3().fromArray(bb[1].positions[0]);
					var h = st.distanceTo(en);
					var bgeometry = new THREE.CylinderGeometry(1,1,h,20);

					bgeometry.translate(0, -h/2, 0 );

					var boneMesh = new THREE.Mesh(bgeometry, bonematerial2);
					boneMesh.joint1Index = bb[0].jointIndex;
					boneMesh.joint2Index = bb[1].jointIndex;

					boneMeshes.push(boneMesh);
					scene.add(boneMesh);
				});
				
			});
		}

		function angle_trunc(a) {
			while (a < 0)
				 a += math.pi * 2;
			//lse
			//	return a;
			return a;
		}

		function animFrame(frame) {
			jointMeshes.forEach(function(joint, index) {
				joint.position.set(
					bvh.jointArray[index].positions[frame][0],
					bvh.jointArray[index].positions[frame][1],
					bvh.jointArray[index].positions[frame][2]);
			});

			boneMeshes.forEach(function(bone, index) {
				firstJoint = bvh.jointArray[bone.joint1Index];
				secondJoint = bvh.jointArray[bone.joint2Index];

				var offsetMat = new THREE.Matrix4();
				offsetMat.set(1,0,0,firstJoint.offset[0],
							  0,1,0,firstJoint.offset[1],
							  0,0,1,firstJoint.offset[2],
							  0,0,0,1);

				
				var rotMat = new THREE.Matrix4();
				var R = firstJoint.rotations[frame];
				rotMat.set(R[0][0],R[1][0],R[2][0],0,
						   R[0][1],R[1][1],R[2][1],0,
						   R[0][2],R[1][2],R[2][2],0,
							0	  ,0      ,0      ,1);


				// rotMat.set(R[0][0],R[0][1],R[0][2],0,
				// 		      R[1][0],R[1][1],R[1][2],0,
				// 		      R[2][0],R[2][1],R[2][2],0,
				// 			0	  ,0      ,0      ,1);				



				bone.rotation.setFromRotationMatrix(rotMat, firstJoint.rotOrder);
				



				bone.position.set(firstJoint.positions[frame][0],
								firstJoint.positions[frame][1],
								firstJoint.positions[frame][2]);


				//bone.applyMatrix(offsetMat.multiply(rotMat));
				/// 4x4 


				/// move origin (.translate)
				/// rotate
				/// translate (world position + offeset)

			});
		}

		function animFrame0(frame) {
			jointMeshes.forEach(function(joint, index) {
				joint.position.set(
					bvh.jointArray[index].positions[frame][0],
					bvh.jointArray[index].positions[frame][1],
					bvh.jointArray[index].positions[frame][2]);
			});

			boneMeshes.forEach(function(bone, index) {
				firstJoint = bvh.jointArray[bone.joint1Index];
				secondJoint = bvh.jointArray[bone.joint2Index];

				dx = secondJoint.positions[frame][0]-firstJoint.positions[frame][0];
				dy = secondJoint.positions[frame][1]-firstJoint.positions[frame][1];
				dz = secondJoint.positions[frame][2]-firstJoint.positions[frame][2];

			var appr = 3;
				if (appr == 1) {				
				theta_z = angle_trunc(math.atan2(dx,dy));
				theta_y = angle_trunc(math.atan2(dz,dx));
				theta_x = angle_trunc(math.atan2(dy,dz));

				bone.rotation.set(theta_x,theta_y,theta_z);
			}
			else if (appr == 2) {
				theta_z = angle_trunc(math.atan2(secondJoint.positions[frame][0],secondJoint.positions[frame][1]) - math.atan2(firstJoint.positions[frame][0],firstJoint.positions[frame][1]));

				theta_y = angle_trunc(math.atan2(secondJoint.positions[frame][0],secondJoint.positions[frame][2]) - math.atan2(firstJoint.positions[frame][0],firstJoint.positions[frame][2]));

				theta_x = angle_trunc(math.atan2(secondJoint.positions[frame][2],secondJoint.positions[frame][1]) - math.atan2(firstJoint.positions[frame][2],firstJoint.positions[frame][1]));

				bone.rotation.set(theta_x,theta_y,theta_z);
			} else if (appr == 3) {
				theta_x = firstJoint.channels[frame][firstJoint.channels[frame].length - 3]* Math.PI / 180;
				theta_y = firstJoint.channels[frame][firstJoint.channels[frame].length - 2]* Math.PI / 180;
				theta_z = firstJoint.channels[frame][firstJoint.channels[frame].length - 1]* Math.PI / 180;

				bone.rotation.set(theta_x,theta_y,theta_z,firstJoint.rotOrder);
			}
				//console.log(theta_y);
				
				// bone.lookAt(new THREE.Vector3(
				// 	firstJoint.positions[frame][0],
				// 	firstJoint.positions[frame][1],
				// 	firstJoint.positions[frame][2]));
				//bone.rotation.z = 0;



				bone.position.set(firstJoint.positions[frame][0]+dx/2,
								firstJoint.positions[frame][1]+dy/2,
								firstJoint.positions[frame][2])+dz/2;

				/// 4x4 


				/// move origin (.translate)
				/// rotate
				/// translate (world position + offeset)

			});

			boneLines.forEach(function(bone, index) {
				firstJoint = bvh.jointArray[bone.joint1Index];
				secondJoint = bvh.jointArray[bone.joint2Index];
				bone.geometry.vertices = [new THREE.Vector3().fromArray(firstJoint.positions[frame]),
							new THREE.Vector3().fromArray(secondJoint.positions[frame])];
						});
		}

		function matrixMultiply(m1, m2) {
			var a = math.matrix(m1);
			var b = math.matrix(m2);
			return math.multiply(a, b).toArray();
		}
		
		$(document).on("keypress", function (e) {
    		if (e.charCode == 32)
    			playing = !playing;

    		if (playing)
    			animStartTimeRef = Date.now();
    		else
    			animOffset = animIndex;
		});
		</script>
		<script>
		var scene, camera, renderer;
		var geometry, material, mesh;
		var onProgress = function ( xhr ) {
			if ( xhr.lengthComputable ) {
				var percentComplete = xhr.loaded / xhr.total * 100;
				console.log( Math.round(percentComplete, 2) + '% downloaded' );
			}
		};

		var onError = function ( xhr ) {
		
		};
		
		init();
		animate();

		function init() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
			camera.position.set( 20, 80, 3 );
			camera.position.z = 300;

			// Lights
			var lights = [];
			lights[0] = new THREE.PointLight( 0xffffff, 1, 0 );
			lights[1] = new THREE.PointLight( 0xffffff, 1, 0 );
			lights[2] = new THREE.PointLight( 0xffffff, 1, 0 );
			lights[0].position.set( 0, 200, 0 );
			lights[1].position.set( 100, 200, 100 );
			lights[2].position.set( -100, -200, -100 );

			scene.add( lights[0] );
			scene.add( lights[1] );
			scene.add( lights[2] );

			var ambientLight = new THREE.AmbientLight( 0x000000 );
			scene.add( ambientLight );

			// Grid
			var size = 160, step = 20;

			var geometry = new THREE.PlaneGeometry( size*2, size*2);
			var material = new THREE.MeshBasicMaterial( {color: 0x707070, side: THREE.DoubleSide, transparent: true, opacity: 0.7} );
			var plane = new THREE.Mesh( geometry, material );
			plane.position.set(0,0,0);
			plane.rotation.set(math.pi/2,0,0);
			scene.add( plane );

			var geometry = new THREE.Geometry();
			var material = new THREE.LineBasicMaterial( { color: 0x222222,linewidth: 1.2 } );
			for ( var i = - size; i <= size; i += step ) {
				geometry.vertices.push( new THREE.Vector3( - size, - 0.04, i ) );
				geometry.vertices.push( new THREE.Vector3(   size, - 0.04, i ) );
				geometry.vertices.push( new THREE.Vector3( i, - 0.04, - size ) );
				geometry.vertices.push( new THREE.Vector3( i, - 0.04,   size ) );
			}

			var line = new THREE.LineSegments( geometry, material );
			scene.add( line );

			

			load_bvh();

			renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );

			renderer.setClearColor( 0xdddddd, 1);
			document.body.appendChild( renderer.domElement );

			controls = new THREE.OrbitControls( camera, renderer.domElement );
		}

		function animate() {
			requestAnimationFrame( animate );
			if (typeof bvh !== 'undefined'){		

			if (playing) {
				animIndex = animOffset + Math.floor( (Date.now() - animStartTimeRef) / bvh.frameTime / 1000);

				if (animIndex >= bvh.frameCount) {
					animOffset = 0;
					animStartTimeRef = Date.now();
					animIndex = 0;
				}

			}
			
			animFrame(animIndex);

			}
			
			renderer.render( scene, camera );
		}
		</script>
	</body>
</html>