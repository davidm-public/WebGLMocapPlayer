<!DOCTYPE html>
<html lang="en">
	<head>
		<title>WebGL Mocap Viewer</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
		</style>
		<script src="js/bvhReader.js"></script>
		<script src="bower_components/mathjs/dist/math.min.js"></script>
		<script src="bower_components/jquery/dist/jquery.min.js"></script>
		<script src="bower_components/three.js/build/three.min.js"></script>
		<script src="bower_components/three.js/examples/js/loaders/ColladaLoader.js"></script>
		<script src="bower_components/three.js/examples/js/loaders/AssimpJSONLoader.js"></script>
		<script src="bower_components/three.js/examples/js/controls/OrbitControls.js"></script>
		<script src="bower_components/three.js/examples/js/loaders/collada/Animation.js"></script>
		<script src="bower_components/three.js/examples/js/controls/OrbitControls.js"></script>
	</head>
	<body>
		<script type="text/javascript">
		var jointMeshes = [];
		var boneMeshes = [];
		var boneLines = [];
		var animIndex = 1;

		function load_bvh() {
			jointmaterial = new THREE.MeshBasicMaterial( { color: 0x0066ff, wireframe: true } );
			jointmaterial2 = new THREE.MeshPhongMaterial({
					color: 0x156289,
					emissive: 0x072534,
					side: THREE.DoubleSide,
					shading: THREE.FlatShading
				});
			bonematerial = new THREE.MeshBasicMaterial( { color: 0x00ff66, wireframe: true } );
			bonematerial2 = new THREE.MeshPhongMaterial({
					color: 0x221133,
					emissive: 0x276734,
					side: THREE.DoubleSide,
					shading: THREE.FlatShading
				});

			console.log("Loading the BVH file ...");

			var reader = new BVHReader();

			reader.load("res/AV_8Walk_Meredith_HVHA_Rep1.bvh", function(data){
				bvh = data;
				console.log("BVH file loaded.");
				bvh.jointArray.forEach(function(joint, index) {
					var jointMesh = new THREE.Mesh(new THREE.SphereGeometry(1,20,20), jointmaterial2);
					jointMesh.bvhIndex = index;
					jointMeshes.push(jointMesh);
					scene.add(jointMesh);
				});
				
				bvh.connectivityMatrix.forEach(function(bb, index) {
					st = new THREE.Vector3().fromArray(bb[0].positions[0]);
					en = new THREE.Vector3().fromArray(bb[1].positions[0]);
					var h = st.distanceTo(en);
					var boneMesh = new THREE.Mesh(new THREE.CylinderGeometry(1,1,h,20), bonematerial2);
					boneMesh.joint1Index = bb[0].jointIndex;
					boneMesh.joint2Index = bb[1].jointIndex;
					boneMesh.rotationAutoUpdate = false;
					boneMeshes.push(boneMesh);
					scene.add(boneMesh);
				});
				// bvh.connectivityMatrix.forEach(function(bb, index) {
					// 	var lineGeometry = new THREE.Geometry();
					// 	lineGeometry.vertices.push(
							// 			new THREE.Vector3().fromArray(bb[0].positions[0]),
							// 			new THREE.Vector3().fromArray(bb[1].positions[0]));
					// 	var boneLine = new THREE.Line(lineGeometry, bonematerial2);
					
					// 	boneLine.joint1Index = bb[0].jointIndex;
					// 	boneLine.joint2Index = bb[1].jointIndex;
					// 	boneLines.push(boneLine);
					// 	scene.add(boneLine);
				// });
				
			});
		}

		function animFrame(frame) {
			jointMeshes.forEach(function(joint, index) {
				joint.position.set(bvh.jointArray[index].positions[frame][0],
					bvh.jointArray[index].positions[frame][1],bvh.jointArray[index].positions[frame][2]);
			});

			boneMeshes.forEach(function(bone, index) {
				firstJoint = bvh.jointArray[bone.joint1Index];
				secondJoint = bvh.jointArray[bone.joint2Index];

				
				


				// torad = Math.PI / 180;
				// var rotMat = new THREE.Matrix4();
				// var R = firstJoint.rotations[frame];
				// rotMat.set(R[0][0],R[1][0],R[2][0],0,
				// 		R[0][1],R[1][1],R[2][1],0,
				// 		R[0][2],R[1][2],R[2][2],0,
				// 			0	  ,0      ,0      ,0);

				//bone.rotation.setFromRotationMatrix(rotMat,"XYZ");

				//bone.rotation.fromArray(firstJoint.channels[frame]);
				// bone.rotation.set(firstJoint.channels[frame][0],
				// 				  firstJoint.channels[frame][1],
				// 				  firstJoint.channels[frame][2]);


				dx = secondJoint.positions[frame][0]-firstJoint.positions[frame][0];
				dy = secondJoint.positions[frame][1]-firstJoint.positions[frame][1];
				dz = secondJoint.positions[frame][2]-firstJoint.positions[frame][2];

				theta_z = math.atan2(-dx,-dy);
				theta_y = math.atan2(-dz,dx);
				theta_x = math.atan2(-dz,-dy);

				bone.rotation.set(theta_x,theta_y,theta_z);
				// bone.rotation.x = firstJoint.channels[firstJoint.rotationIndex.x] * torad;
				// bone.rotation.y = firstJoint.channels[firstJoint.rotationIndex.y] * torad;
				// bone.rotation.z = firstJoint.channels[firstJoint.rotationIndex.z] * torad;
				// bone.rotation.x = bone.rotation.x * torad;
				// bone.rotation.y = bone.rotation.y * torad;
				// bone.rotation.z = bone.rotation.z * torad;


				h = bone.geometry.parameters.height;
				bone.position.set(firstJoint.positions[frame][0]+dx/2,
								firstJoint.positions[frame][1]+dy/2,
								firstJoint.positions[frame][2])+dz/2;
			});

			boneLines.forEach(function(bone, index) {
				firstJoint = bvh.jointArray[bone.joint1Index];
				secondJoint = bvh.jointArray[bone.joint2Index];
				bone.geometry.vertices = [new THREE.Vector3().fromArray(firstJoint.positions[frame]),
							new THREE.Vector3().fromArray(secondJoint.positions[frame])];
						});
		}

		function matrixMultiply(m1, m2) {
			var a = math.matrix(m1);
			var b = math.matrix(m2);
			return math.multiply(a, b).toArray();
		}
		
		</script>
		<script>
		var scene, camera, renderer;
		var geometry, material, mesh;
		var onProgress = function ( xhr ) {
			if ( xhr.lengthComputable ) {
				var percentComplete = xhr.loaded / xhr.total * 100;
				console.log( Math.round(percentComplete, 2) + '% downloaded' );
			}
		};

		var onError = function ( xhr ) {
		
		};
		
		init();
		animate();

		function init() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
			camera.position.set( 20, 80, 3 );
			camera.position.z = 300;

			// Lights
			var lights = [];
			lights[0] = new THREE.PointLight( 0xffffff, 1, 0 );
			lights[1] = new THREE.PointLight( 0xffffff, 1, 0 );
			lights[2] = new THREE.PointLight( 0xffffff, 1, 0 );
			lights[0].position.set( 0, 200, 0 );
			lights[1].position.set( 100, 200, 100 );
			lights[2].position.set( -100, -200, -100 );

			scene.add( lights[0] );
			scene.add( lights[1] );
			scene.add( lights[2] );

			var ambientLight = new THREE.AmbientLight( 0x000000 );
			scene.add( ambientLight );

			// Grid
			var size = 160, step = 20;

			var geometry = new THREE.PlaneGeometry( size*2, size*2);
			var material = new THREE.MeshBasicMaterial( {color: 0x707070, side: THREE.DoubleSide, transparent: true, opacity: 0.7} );
			var plane = new THREE.Mesh( geometry, material );
			plane.position.set(0,0,0);
			plane.rotation.set(math.pi/2,0,0);
			scene.add( plane );

			var geometry = new THREE.Geometry();
			var material = new THREE.LineBasicMaterial( { color: 0x222222,linewidth: 1.2 } );
			for ( var i = - size; i <= size; i += step ) {
				geometry.vertices.push( new THREE.Vector3( - size, - 0.04, i ) );
				geometry.vertices.push( new THREE.Vector3(   size, - 0.04, i ) );
				geometry.vertices.push( new THREE.Vector3( i, - 0.04, - size ) );
				geometry.vertices.push( new THREE.Vector3( i, - 0.04,   size ) );
			}

			var line = new THREE.LineSegments( geometry, material );
			scene.add( line );

			

			load_bvh();

			renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0xdddddd, 1);
			document.body.appendChild( renderer.domElement );

			controls = new THREE.OrbitControls( camera, renderer.domElement );
		}

		function animate() {
			requestAnimationFrame( animate );
			if (typeof bvh !== 'undefined'){
			animFrame(animIndex);
			animIndex++;
			animIndex = animIndex % bvh.frameCount
			//  if ( Bvh.play.checked ) {
			// var frame = ( (Date.now() - Bvh.startTime ) / Bvh.secsPerFrame / 1000) | 0;
			// Bvh.animate( frame ); }
			}
			
			renderer.render( scene, camera );
		}
		</script>
	</body>
</html>